Рабочая тетрадь №2 Циклы
Задание №1
using System;
using System.Globalization;

enum SeriesType
{
	Exp = 1,      // e^x
	Sin = 2,      // sin x
	Cos = 3,      // cos x
	Ln1px = 4,    // ln(1 + x), |x| < 1
	Arctan = 5,   // arctan x, |x| <= 1
	Geom = 6      // 1 / (1 - x), |x| < 1
}

class Program
{
	static void Main()
	{
		Console.OutputEncoding = System.Text.Encoding.UTF8;
		Console.WriteLine("Выберите функцию для разложения в ряд:");
		Console.WriteLine("1 - e^x");
		Console.WriteLine("2 - sin x");
		Console.WriteLine("3 - cos x");
		Console.WriteLine("4 - ln(1 + x)  (|x| < 1)");
		Console.WriteLine("5 - arctan x   (|x| <= 1)");
		Console.WriteLine("6 - 1/(1 - x)  (|x| < 1)");
		Console.Write("Ваш выбор: ");

		if (!int.TryParse(Console.ReadLine(), out int choice) || choice < 1 || choice > 6)
		{
			Console.WriteLine("Некорректный выбор.");
			return;
		}
		var seriesType = (SeriesType)choice;

		double x = ReadDouble("Введите x: ");
		double epsilon = ReadDouble("Введите точность e (0 < e < 0.01): ");
		if (!(epsilon > 0 && epsilon < 0.01))
		{
			Console.WriteLine("Точность должна быть в диапазоне (0; 0.01).");
			return;
		}

		if (!IsInConvergenceDomain(seriesType, x))
		{
			Console.WriteLine("Значение x не удовлетворяет области сходимости выбранного ряда.");
			return;
		}

		(int termsUsed, double sum) = CalculateSeries(seriesType, x, epsilon);
		Console.WriteLine($"Значение функции с точностью {epsilon}: {sum}");
		Console.WriteLine($"Суммировано членов: {termsUsed}");

		Console.Write("\nВведите номер члена ряда (n, n >= 1): ");
		if (!int.TryParse(Console.ReadLine(), out int n) || n < 1)
		{
			Console.WriteLine("n должно быть целым числом >= 1.");
			return;
		}

		double nthTerm = GetNthTerm(seriesType, x, n);
		Console.WriteLine($"Значение {n}-го члена ряда: {nthTerm}");
	}

	static double ReadDouble(string prompt)
	{
		Console.Write(prompt);
		var s = Console.ReadLine();
		if (double.TryParse(s, NumberStyles.Float, CultureInfo.GetCultureInfo("ru-RU"), out double vRu))
			return vRu;
		if (double.TryParse(s, NumberStyles.Float, CultureInfo.InvariantCulture, out double vInv))
			return vInv;
		throw new FormatException("Некорректный ввод числа.");
	}

	static bool IsInConvergenceDomain(SeriesType type, double x)
	{
		switch (type)
		{
			case SeriesType.Exp:
			case SeriesType.Sin:
			case SeriesType.Cos:
				return true; // сходится для любых x
			case SeriesType.Ln1px:
				return Math.Abs(x) < 1; // ряд Маклорена для ln(1+x): |x| < 1
			case SeriesType.Arctan:
				return Math.Abs(x) <= 1; // |x| <= 1
			case SeriesType.Geom:
				return Math.Abs(x) < 1; // 1/(1-x): |x| < 1
			default:
				return false;
		}
	}

	static double Factorial(int n)
	{
		if (n < 0) throw new ArgumentOutOfRangeException(nameof(n));
		if (n == 0) return 1.0;
		double result = 1.0;
		for (int i = 1; i <= n; i++)
			result *= i;
		return result;
	}

	// n — 1-индексация: первый член ряда соответствует n = 1.
	static double GetNthTerm(SeriesType type, double x, int n)
	{
		switch (type)
		{
			case SeriesType.Exp:
			{
				int k = n - 1; // k = 0,1,2,...
				return Math.Pow(x, k) / Factorial(k);
			}
			case SeriesType.Sin:
			{
				int k = n - 1; // sin: Σ (-1)^k x^(2k+1)/(2k+1)!, k=0..∞
				double sign = (k % 2 == 0) ? 1.0 : -1.0;
				return sign * Math.Pow(x, 2 * k + 1) / Factorial(2 * k + 1);
			}
			case SeriesType.Cos:
			{
				int k = n - 1; // cos: Σ (-1)^k x^(2k)/(2k)!, k=0..∞
				double sign = (k % 2 == 0) ? 1.0 : -1.0;
				return sign * Math.Pow(x, 2 * k) / Factorial(2 * k);
			}
			case SeriesType.Ln1px:
			{
				// ln(1+x): Σ (-1)^(k+1) x^k / k, k=1..∞
				int k = n; // здесь первый член — при k=1
				double sign = ((k + 1) % 2 == 0) ? 1.0 : -1.0; // (-1)^(k+1)
				return sign * Math.Pow(x, k) / k;
			}
			case SeriesType.Arctan:
			{
				int k = n - 1; // arctan x: Σ (-1)^k x^(2k+1)/(2k+1), k=0..∞
				double sign = (k % 2 == 0) ? 1.0 : -1.0;
				return sign * Math.Pow(x, 2 * k + 1) / (2 * k + 1);
			}
			case SeriesType.Geom:
			{
				int k = n - 1; // 1/(1-x): Σ x^k, k=0..∞
				return Math.Pow(x, k);
			}
			default:
				throw new NotSupportedException("Неизвестный тип ряда.");
		}
	}

	// Возвращает (кол-во просуммированных членов, сумма)
	static (int termsUsed, double sum) CalculateSeries(SeriesType type, double x, double epsilon)
	{
		double sum = 0.0;
		int n = 1;
		while (true)
		{
			double term = GetNthTerm(type, x, n);
			if (Math.Abs(term) <= epsilon)
				break;
			sum += term;
			n++;
			// защита от чрезвычайно длинных вычислений в краевых случаях
			if (n > 2_000_000)
				throw new InvalidOperationException("Слишком много членов для достижения заданной точности.");
		}
		return (n - 1, sum);
	}
}

Задание №2
using System;

class Program
{
    static void Main()
    {
        // Получаем номер билета от пользователя
        Console.Write("Введите шестизначный номер билета: ");
        string input = Console.ReadLine();
        
        // Проверяем корректность ввода
        if (!IsValidTicketNumber(input))
        {
            Console.WriteLine("Ошибка: введите корректный шестизначный номер");
            return;
        }
        
        // Преобразуем строку в число
        int ticketNumber = int.Parse(input);
        
        // Извлекаем отдельные цифры без использования массивов
        int digit1 = ticketNumber / 100000;
        int digit2 = (ticketNumber / 10000) % 10;
        int digit3 = (ticketNumber / 1000) % 10;
        int digit4 = (ticketNumber / 100) % 10;
        int digit5 = (ticketNumber / 10) % 10;
        int digit6 = ticketNumber % 10;
        
        // Вычисляем суммы
        int sumFirst = digit1 + digit2 + digit3;
        int sumLast = digit4 + digit5 + digit6;
        
        // Выводим результат
        if (sumFirst == sumLast)
        {
            Console.WriteLine("Билет счастливый!");
        }
        else
        {
            Console.WriteLine("Билет обычный.");
        }
        
        // Дополнительная информация (по желанию)
        Console.WriteLine($"Сумма первых трех цифр: {sumFirst}");
        Console.WriteLine($"Сумма последних трех цифр: {sumLast}");
    }
    
    // Вспомогательный метод для проверки корректности номера билета
    static bool IsValidTicketNumber(string str)
    {
        // Проверяем длину строки
        if (str.Length != 6)
            return false;
            
        // Проверяем, что все символы - цифры
        foreach (char c in str)
        {
            if (c < '0' || c > '9')
                return false;
        }
        
        // Проверяем, что число шестизначное (не начинается с 0)
        if (str[0] == '0')
            return false;
            
        return true;
    }
}

Задание №3
using System;

class Program
{
    static void Main()
    {
        try
        {
            // Ввод чисел
            Console.Write("Введите числитель M: ");
            int m = int.Parse(Console.ReadLine());

            Console.Write("Введите знаменатель N: ");
            int n = int.Parse(Console.ReadLine());

            // Проверка знаменателя
            if (n == 0)
            {
                Console.WriteLine("Ошибка: знаменатель не может быть равен нулю!");
                return;
            }

            // Обработка нулевого числителя
            if (m == 0)
            {
                Console.WriteLine("Несократимая дробь: 0");
                return;
            }

            // Находим НОД (учитываем отрицательные числа)
            int gcd = FindGCD(Math.Abs(m), Math.Abs(n));

            // Сокращаем дробь
            int numerator = m / gcd;
            int denominator = n / gcd;

            // Обработка отрицательных чисел
            if (denominator < 0)
            {
                numerator = -numerator;
                denominator = -denominator;
            }

            // Выводим результат
            if (denominator == 1)
            {
                Console.WriteLine($"Несократимая дробь: {numerator}");
            }
            else
            {
                Console.WriteLine($"Несократимая дробь: {numerator}/{denominator}");
            }

            // Дополнительная информация
            Console.WriteLine($"Исходная дробь: {m}/{n}");
            Console.WriteLine($"НОД({m}, {n}) = {gcd}");
        }
        catch (FormatException)
        {
            Console.WriteLine("Ошибка: введите целые числа!");
        }
        catch (OverflowException)
        {
            Console.WriteLine("Ошибка: введено слишком большое число!");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Произошла ошибка: {ex.Message}");
        }
    }

    // Метод для нахождения НОД (алгоритм Евклида)
    static int FindGCD(int a, int b)
    {
        while (b != 0)
        {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}

Задание №4
using System;

class NumberGuesser
{
    static void Main()
    {
        Console.WriteLine("Загадайте число от 0 до 63. Я попробую его угадать.");
        Console.WriteLine("Отвечайте '1' (да) или '0' (нет) на мои вопросы.");
        Console.WriteLine();

        try
        {
            // Инициализация переменных для бинарного поиска
            int lower = 0;
            int upper = 63;
            int result = 0;
            int questionCount = 0;

            // Битовые маски для проверки каждого разряда числа
            int[] masks = { 32, 16, 8, 4, 2, 1 };

            foreach (int mask in masks)
            {
                questionCount++;
                int currentGuess = lower + mask;
                
                Console.Write($"Вопрос {questionCount}: Ваше число больше или равно {currentGuess}? (1/0): ");
                string answer = Console.ReadLine();

                // Проверка корректности ввода
                if (answer != "0" && answer != "1")
                {
                    Console.WriteLine("Ошибка: введите только '1' или '0'");
                    questionCount--;
                    continue;
                }

                if (answer == "1")
                {
                    // Устанавливаем бит и сдвигаем нижнюю границу
                    result |= mask;
                    lower += mask;
                    Console.WriteLine($"  Число в диапазоне [{lower}, {upper}]");
                }
                else
                {
                    // Сдвигаем верхнюю границу
                    upper = lower + mask - 1;
                    Console.WriteLine($"  Число в диапазоне [{lower}, {upper}]");
                }
                
                Console.WriteLine();
            }

            // Вывод результата
            Console.WriteLine("Результат:");
            Console.WriteLine($"Задано вопросов: {questionCount}");
            Console.WriteLine($"Ваше число: {result}!");
            
            // Обратная связь
            Console.Write("Я угадал? (1 - да, 0 - нет): ");
            string feedback = Console.ReadLine();
            
            if (feedback == "1")
            {
                Console.WriteLine("Ура! Я угадал!");
            }
            else
            {
                Console.WriteLine("Попробуем еще раз!");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка: {ex.Message}");
        }
    }
}

Задание №5
using System;

class CoffeeMachine
{
    // Параметры напитков
    private const int AMERICANO_WATER = 300;
    private const int LATTE_WATER = 30;
    private const int LATTE_MILK = 270;
    private const int AMERICANO_PRICE = 150;
    private const int LATTE_PRICE = 170;

    private int water;
    private int milk;
    private int americanoCount;
    private int latteCount;
    private int totalIncome;

    public void Start()
    {
        // Инициализация счетчиков
        americanoCount = 0;
        latteCount = 0;
        totalIncome = 0;

        // Запрашиваем начальные запасы
        Console.Write("Введите количество воды (мл): ");
        water = int.Parse(Console.ReadLine());

        Console.Write("Введите количество молока (мл): ");
        milk = int.Parse(Console.ReadLine());

        // Основной цикл обслуживания
        while (CanMakeAnyDrink())
        {
            ProcessOrder();
        }

        // Генерация отчета при завершении
        GenerateReport();
    }

    private bool CanMakeAnyDrink()
    {
        // Проверяем, можно ли приготовить хотя бы один напиток
        return (water >= AMERICANO_WATER) || (water >= LATTE_WATER && milk >= LATTE_MILK);
    }

    private void ProcessOrder()
    {
        Console.WriteLine("\nВыберите напиток:");
        Console.WriteLine("1 - Американо");
        Console.WriteLine("2 - Латте");
        Console.Write("Ваш выбор: ");

        int choice = int.Parse(Console.ReadLine());

        switch (choice)
        {
            case 1:
                MakeAmericano();
                break;
            case 2:
                MakeLatte();
                break;
            default:
                Console.WriteLine("Неверный выбор");
                break;
        }
    }

    private void MakeAmericano()
    {
        if (water >= AMERICANO_WATER)
        {
            water -= AMERICANO_WATER;
            americanoCount++;
            totalIncome += AMERICANO_PRICE;
            Console.WriteLine("Ваш напиток готов");
        }
        else
        {
            Console.WriteLine("Не хватает воды");
        }
        ShowRemainingResources();
    }

    private void MakeLatte()
    {
        if (water >= LATTE_WATER && milk >= LATTE_MILK)
        {
            water -= LATTE_WATER;
            milk -= LATTE_MILK;
            latteCount++;
            totalIncome += LATTE_PRICE;
            Console.WriteLine("Ваш напиток готов");
        }
        else if (water < LATTE_WATER)
        {
            Console.WriteLine("Не хватает воды");
        }
        else
        {
            Console.WriteLine("Не хватает молока");
        }
        ShowRemainingResources();
    }

    private void ShowRemainingResources()
    {
        Console.WriteLine($"Остаток воды: {water} мл");
        Console.WriteLine($"Остаток молока: {milk} мл");
    }

    private void GenerateReport()
    {
        Console.WriteLine("\n=== ОТЧЕТ ===");
        Console.WriteLine("Ингредиенты подошли к концу");
        Console.WriteLine($"Остаток воды: {water} мл");
        Console.WriteLine($"Остаток молока: {milk} мл");
        Console.WriteLine($"Приготовлено американо: {americanoCount} чашек");
        Console.WriteLine($"Приготовлено латте: {latteCount} чашек");
        Console.WriteLine($"Итоговый заработок: {totalIncome} рублей");
    }

    static void Main()
    {
        CoffeeMachine machine = new CoffeeMachine();
        machine.Start();
    }
}

Задание №6
using System;

class Program
{
    static void Main()
    {
        // Ввод начальных данных
        Console.Write("Введите количество бактерий (N): ");
        int N = int.Parse(Console.ReadLine());

        Console.Write("Введите количество капель антибиотика (X): ");
        int X = int.Parse(Console.ReadLine());

        int bacteria = N; // текущее количество бактерий
        int hours = 0; // счетчик часов
        int antibioticEffectiveness = 10; // начальная эффективность одной капли

        Console.WriteLine("\nДинамика изменения количества бактерий:");

        // Цикл моделирования процесса
        while (bacteria > 0 && antibioticEffectiveness > 0)
        {
            hours++;

            // Бактерии удваиваются
            bacteria *= 2;
            Console.WriteLine($"После размножения: {bacteria} бактерий");

            // Антибиотик убивает бактерии
            int killedBacteria = X * antibioticEffectiveness;
            bacteria -= killedBacteria;

            // Количество бактерий не может быть отрицательным
            if (bacteria < 0) bacteria = 0;

            Console.WriteLine($"Час {hours}: Бактерий = {bacteria}, Убито бактерий = {killedBacteria}");

            // Эффективность антибиотика уменьшается
            antibioticEffectiveness--;

            // Проверка условий завершения
            if (bacteria == 0)
            {
                Console.WriteLine("Все бактерии уничтожены!");
                break;
            }
            
            if (antibioticEffectiveness == 0)
            {
                Console.WriteLine("Антибиотик перестал действовать!");
                break;
            }
        }

        Console.WriteLine($"\nПроцесс завершен через {hours} часов");
        Console.WriteLine($"Конечное количество бактерий: {bacteria}");
    }
}

Задание №7
using System;

class Program
{
    static void Main()
    {
        try
        {
            // Ввод данных
            Console.Write("Введите количество модулей (n): ");
            int n = int.Parse(Console.ReadLine());

            Console.Write("Введите размеры модуля (a b): ");
            string[] input = Console.ReadLine().Split();
            int a = int.Parse(input[0]);
            int b = int.Parse(input[1]);

            Console.Write("Введите размеры поля (w h): ");
            input = Console.ReadLine().Split();
            int w = int.Parse(input[0]);
            int h = int.Parse(input[1]);

            // Вычисление максимальной толщины защиты
            int maxD = CalculateMaxProtection(n, a, b, w, h);

            if (maxD == -1)
            {
                Console.WriteLine("Невозможно разместить модули даже без защиты");
            }
            else
            {
                Console.WriteLine($"Максимальная толщина защиты: {maxD}");
                
                // Дополнительная информация
                int finalWidth = a + 2 * maxD;
                int finalHeight = b + 2 * maxD;
                Console.WriteLine($"Размер модуля с защитой: {finalWidth} x {finalHeight}");
                
                // Проверка размещения в обоих ориентациях
                CheckPlacement(n, a, b, w, h, maxD);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка: {ex.Message}");
        }
    }

    static int CalculateMaxProtection(int n, int a, int b, int w, int h)
    {
        // Проверяем возможность размещения без защиты
        if (!CanPlaceModules(n, a, b, w, h, 0))
            return -1;

        // Бинарный поиск максимальной толщины
        int left = 0;
        int right = Math.Min(w, h); // Максимально возможная толщина защиты
        int result = 0;

        while (left <= right)
        {
            int mid = (left + right) / 2;
            
            if (CanPlaceModules(n, a, b, w, h, mid))
            {
                result = mid;
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        
        return result;
    }

    static bool CanPlaceModules(int n, int a, int b, int w, int h, int d)
    {
        // Размеры модуля с защитой
        int aWithD = a + 2 * d;
        int bWithD = b + 2 * d;

        // Проверяем оба варианта ориентации
        bool orientation1 = CanFit(n, aWithD, bWithD, w, h);
        bool orientation2 = CanFit(n, bWithD, aWithD, w, h);

        return orientation1 || orientation2;
    }

    static bool CanFit(int n, int moduleWidth, int moduleHeight, int fieldWidth, int fieldHeight)
    {
        // Проверяем, что модуль вообще помещается в поле
        if (moduleWidth > fieldWidth || moduleHeight > fieldHeight)
            return false;

        // Максимальное количество модулей по ширине и высоте
        int maxWidth = fieldWidth / moduleWidth;
        int maxHeight = fieldHeight / moduleHeight;

        // Общее количество модулей, которые можно разместить
        int totalModules = maxWidth * maxHeight;

        return totalModules >= n;
    }

    static void CheckPlacement(int n, int a, int b, int w, int h, int d)
    {
        int aWithD = a + 2 * d;
        int bWithD = b + 2 * d;

        Console.WriteLine("\nПроверка размещения:");
        
        // Ориентация 1: a - ширина, b - высота
        int modulesW1 = w / aWithD;
        int modulesH1 = h / bWithD;
        int total1 = modulesW1 * modulesH1;
        Console.WriteLine($"Ориентация 1 ({aWithD} x {bWithD}): {modulesW1} x {modulesH1} = {total1} модулей");

        // Ориентация 2: b - ширина, a - высота  
        int modulesW2 = w / bWithD;
        int modulesH2 = h / aWithD;
        int total2 = modulesW2 * modulesH2;
        Console.WriteLine($"Ориентация 2 ({bWithD} x {aWithD}): {modulesW2} x {modulesH2} = {total2} модулей");

        bool canPlace1 = total1 >= n;
        bool canPlace2 = total2 >= n;
        
        Console.WriteLine($"Можно разместить {n} модулей: {(canPlace1 || canPlace2 ? "ДА" : "НЕТ")}");
    }
}